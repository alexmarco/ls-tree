---
description: Normas para escribir c√≥digo python limpio, consistente y profesional
alwaysApply: false
---
# Normas de Desarrollo con Python

Para escribir c√≥digo limpio, consistente y profesional, seguiremos estas directrices clave. El objetivo es maximizar la
automatizaci√≥n y la coherencia.

## 1. Gesti√≥n de Dependencias con `uv` y `pyproject.toml`

La **√∫nica fuente de verdad** sobre las dependencias es el fichero `pyproject.toml`. El entorno virtual es solo un
reflejo de este fichero.

### 1.1 Para A√±adir/Actualizar una Dependencia

1. **Edita manualmente** el `pyproject.toml` y a√±ade la librer√≠a.
2. **Sincroniza** tu entorno con el comando: `uv sync --all-extras`.

### 1.2 Para Sincronizar tu Entorno (tras un `git pull`)

Usa siempre `uv sync --all-extras` para asegurar que tu entorno es id√©ntico al `pyproject.toml`.

## 2. Formateo y Calidad de C√≥digo con `Ruff`

Usamos **Ruff** para todo: formateo (con un **l√≠mite de l√≠nea de 100 caracteres**), detecci√≥n de errores y ordenaci√≥n
de `imports`.

### 2.1 Regla

Antes de hacer un `commit`, ejecuta: primero `uv run ruff format .` y despu√©s `uv run ruff check --fix .`.

## 3. An√°lisis de Tipado con `mypy` üè∑Ô∏è

El uso de **type hints es obligatorio**. `mypy` es nuestra herramienta para validar que el tipado es correcto.

### 3.1 Regla

Antes de confirmar tus cambios, comprueba que el c√≥digo pasa la verificaci√≥n de `mypy` sin errores. Comando
`uv run mypy .`

## 4. Principios Clave del Tipado Est√°tico üß†

M√°s all√° de la herramienta, aplicaremos esta filosof√≠a para que el tipado sea √∫til y no un estorbo. El objetivo es la
**claridad y la prevenci√≥n de bugs**.

### 4.1. Las Firmas de las Funciones son Sagradas

Toda funci√≥n debe tener tipados sus argumentos y su valor de retorno.

```python
# Correcto
def procesar_usuario(user_id: int, es_admin: bool) -> dict[str, any]:
    # ...
    return {}
```

### 4.2. S√© Espec√≠fico, Evita los Tipos Gen√©ricos

Tipar algo como `list` o `dict` es mejor que nada, pero aporta poco valor. S√© tan espec√≠fico como sea posible.

```python
# No hagas esto
def obtener_nombres(usuarios: list) -> list:
    # ...

# Haz esto
def obtener_nombres(usuarios: list[dict[str, any]]) -> list[str]:
    # ...
```

### 4.3. Usa `TypeAlias` para Simplificar Tipos Complejos

Cuando un tipo se vuelve complejo o se repite mucho, crea un alias. Esto hace el c√≥digo inmensamente m√°s legible.

```python
from typing import TypeAlias

# Definimos un alias para un tipo complejo
Usuario: TypeAlias = dict[str, str | int]

# El alias hace la firma de la funci√≥n mucho m√°s limpia
def saludar_usuario(usuario: Usuario) -> str:
    return f"Hola, {usuario['nombre']}"
```

### 4.4 Usa `| None` para Valores Opcionales

Si una variable puede ser de un tipo o `None`, ind√≠calo expl√≠citamente. Esto obliga a quien use la funci√≥n a comprobar
si el valor es nulo, previniendo incontables errores.

```python
def buscar_email(user_id: int) -> str | None:
    # ... Si no se encuentra, retorna None
    return None
```

### 4.5. `Any` es el √öltimo Recurso

Usar `Any` es decirle a `mypy`: "No revises esta parte". Es una v√≠a de escape necesaria a veces (ej: librer√≠as sin
tipos), pero su uso excesivo anula los beneficios del tipado. Siempre intenta encontrar un tipo m√°s espec√≠fico antes de
recurrir a `Any`.

## 5. Documentaci√≥n y Nomenclatura üìñ

* **Docstrings:** Usa el **estilo de Numpy** para documentar. Incluye ejemplos, retornos, y notas si fuera necesario
* **Nomenclatura:** `snake_case` (variables/funciones), `PascalCase` (clases), `UPPER_SNAKE_CASE` (constantes).

## 6. Pruebas (Testing) ‚úÖ

* **Framework:** Usaremos **pytest**.
* **Regla:** Toda nueva funcionalidad o correcci√≥n debe ir acompa√±ada de sus pruebas.
