---
description: Standards for writing clean, consistent, and professional Python code
alwaysApply: false
---

# Python Development Standards

To write clean, consistent, and professional code, we will follow these key guidelines. The goal is to maximize
automation and coherence.

## 1. Dependency Management with `uv` and `pyproject.toml`

The **single source of truth** for dependencies is the `pyproject.toml` file. The virtual environment is just a reflection of this file.

### 1.1 To Add/Update a Dependency

1. **Manually edit** the `pyproject.toml` and add the library.
2. **Sync** your environment with the command: `uv sync --all-extras`.

### 1.2 To Sync Your Environment (after a `git pull`)

Always use `uv sync --all-extras` to ensure your environment is identical to `pyproject.toml`.

## 2. Code Formatting and Quality with `Ruff`

We use **Ruff** for everything: formatting (with a **100-character line limit**), error detection, and `import` sorting.

### 2.1 Rule

Before making a `commit`, run: first `uv run ruff format .` and then `uv run ruff check --fix .`.

## 3. Type Analysis with `mypy` 🏷️

**Type hints are mandatory**. `mypy` is our tool to validate that typing is correct.

### 3.1 Rule

Before confirming your changes, ensure the code passes `mypy` verification without errors. Command: `uv run mypy .`

## 4. Key Principles of Static Typing 🧠

Beyond the tool, we will apply this philosophy so that typing is useful and not a hindrance. The goal is **clarity and bug prevention**.

### 4.1. Function Signatures are Sacred

Every function must have its arguments and return value typed.

```python
# Correct
def process_user(user_id: int, is_admin: bool) -> dict[str, any]:
    # ...
    return {}
```

### 4.2. Be Specific, Avoid Generic Types

Typing something as `list` or `dict` is better than nothing, but adds little value. Be as specific as possible.

```python
# Don't do this
def get_names(users: list) -> list:
    # ...

# Do this
def get_names(users: list[dict[str, any]]) -> list[str]:
    # ...
```

### 4.3. Use `TypeAlias` to Simplify Complex Types

When a type becomes complex or is repeated frequently, create an alias. This makes the code immensely more readable.

```python
from typing import TypeAlias

# Define an alias for a complex type
User: TypeAlias = dict[str, str | int]

# The alias makes the function signature much cleaner
def greet_user(user: User) -> str:
    return f"Hello, {user['name']}"
```

### 4.4 Use `| None` for Optional Values

If a variable can be of a type or `None`, indicate it explicitly. This forces whoever uses the function to check if the value is null, preventing countless errors.

```python
def find_email(user_id: int) -> str | None:
    # ... If not found, returns None
    return None
```

### 4.5. `Any` is the Last Resort

Using `Any` is telling `mypy`: "Don't review this part". It's a necessary escape route sometimes (e.g., libraries without types), but excessive use negates the benefits of typing. Always try to find a more specific type before resorting to `Any`.

## 5. Documentation and Naming 📖

* **Docstrings:** Use **NumPy style** for documentation. Include examples, returns, and notes if necessary
* **Naming:** `snake_case` (variables/functions), `PascalCase` (classes), `UPPER_SNAKE_CASE` (constants).

## 6. Testing ✅

* **Framework:** We will use **pytest**.
* **Rule:** Every new feature or fix must be accompanied by its tests.

## 7. Package Testing with `uvx`

* **Testing installations:** Use `uvx package-name` to test package installation and execution
* **Dependency verification:** Ensure all dependencies are properly declared in `pyproject.toml`
* **Cross-platform testing:** Test on different operating systems when possible

## 8. Code Language

* **Code comments:** Always in English
* **Docstrings:** Always in English
* **Variable names:** Always in English
* **Function names:** Always in English
* **Class names:** Always in English
* **Error messages:** Always in English
